Shell基础
	BASE_PATH=`dirname $0`"/..": 切换到当前目录,并退后一层
	$$: shell本身的PID
	$!: shell最后运行的后台进程的PID
	$?: 最后运行的命令的返回值
	$*: 所有的参数列表($1,$2..)
	$#: shell的参数个数
	$0: shell本身的文件名(配合dirname使用返回当前文件路径)
	$* : 按顺序显示shell脚本中输入的所有参数
	$@ : 按顺序显示shell脚本中输入的所有参数,和$*功能类似,但是可以当做数组用
	==: 等于(比较数字类型)
	-gt: 大于(比较字符串类型)
	-lt: 小于(比较字符串类型)
	-ge: 大于或等于(比较字符串类型)
	-le: 小于或等于(比较字符串类型)
	-eq: 等于(比较字符串类型)
	-ne: 不等于(比较字符串类型)
	>: 覆盖
	>>: 追加
	grep -A1 *: 查询当前行和他的下一行 例子:jstack $pid | grep -A1 http-nio| grep -A1 -exec >$file
	sed -i '/--/d' $file: 删除文件中的指定内容行
	sed -n '{N;s/\n/\t/p}' $file: 把文件中内容两行两行的合并
	-o: or,或者
	-a: and,与
	-z: 判断变量的值是否为空.为空返回0,为true   非空返回1,为false
	-n: 判断变量的值是否为空.为空返回1,为false  非空返回0,为true
	0: 标准输入
	1: 标准输出
	2: 标准错误输出
	2>&1: 把标准错误输出重定向到标准输出,里面既有标准输出,又有错误输出内容
	> /dev/null: 将标准输出1重定向到/dev/null中,/dev/null代表linux的空设备文件,往这个文件里面写入的
								内容都会丢失,当执行了这个表示标准输出就会不在存在,没有任何地方能够找到输出的内容
	> /dev/null 2>&1: shell脚本是从左到右执行的,也就是把标准输出和错误输出都丢弃
	2>&1 >/dev/null: 错误输出输出到屏幕,标准输出丢弃
	nohup: 后台运行,默认输出到当前nohup.out中							
	ps -x | grep 应用名| grep -v grep | awk '{print $1}': 一般获取一个应用进程号的脚本
	md5sum: 计算某个文件或目录的md5
	awk -F: '{print $1}' $file: 表示file文件中每行数据以":"分割后打印出第一个字段
	awk -F= '{print $1}' $file: 表示file文件中每行数据以"="分割后打印出第一个字段
	dirname /home/dosc.txt: 显示指定文件或目录的路径
	ps p PID -L -o pcup,pid,tid,cmd: 查看进程对应的所有线程
	jmap -histo:live PID | grep "T4CConnection": 查看当前进程的数据库连接数
	find /home/dosc -mtime +2 -type -f -name "dosc*" -exec rm -rf {} \: 删除指定路径(/home/dosc)下指定天数(2)后的指定规格文件(dosc*)
	find /home/dosc -mtime +2 -type -d -name "dosc*" -exec rm -rf {} \: 删除指定路径(/home/dosc)下指定天数(2)后的指定规格目录(dosc*)
	netstat -tunlp|egrep "(9151|9152|9152|9154|9155)": 查看多个端口的状态
	netstat -antup | grep ftp: 查询ftp对应的端口
	netstat -ltnp | grep pid/port: 通过pid查询端口号,通过端口号查询pid
	diff -Nrq a b:迭代比较a和b目录的不同
	useradd -m dosc: 创建用户
	userdel -r dosc: 删除用户
	groupadd dosc: 创建组
	groupdel dosc: 删除组

