JAVA基础

HashMap的性质
	1.HashMap实现了Map接口,提供了map的所有操作,允许key,value的值为null
	2.HashMap大致等价于HashTable,除了非同步和允许为null值
	3.HashMap在操作时不能保证顺序,特别是不能保证数据插入随时间保持稳定和顺序
	4.HashMap提供稳定时间的操作,假设hash()方法是分散在桶之间合适的放置元素

HashMap的组成
	1.HashMap由数组和链表组成
	2.外层是数组,数组中每个元素存储的是key,value形成的实例(entry/node)
	3.在执行put()插入时,会根据key的hash去计算一个index,根据index找到数组下标,把key和value写入数组中(数组的单元对象时entry/node)
	4.因为数组的长度是有限的,在有限的长度中进行hash计算可能存在hash冲突,此时就会出现同一个数组下标下需要存储多个entry节点就形成了链表
	5.通过Node的源码可知,每个node节点都会存储: key的hash值,key,value,以及下一个node节点

HashMap的头插法和尾插法
	1.jdk1.8前采用的是头插法,作者认为新的数据被使用的概率会大一点
	2.jdk1.8和之后的版本用的是尾插法,为的是解决头插法在HashMap扩容中可能会造成的死循环

HashMap的扩容
	1.数组的容量是有限的,当数组中实例数达到一定数量后就会进行扩容,扩容涉及的两个参数: (Capacity:HashMap当前长度/LoadFactor:负载因子,默认为0.75)
		例如HashMap初始默认容量为16,当存储到13(16*0.75+1)时就会出现扩容
	2.扩容会新建一个大小为原来两倍的空entry数组
	3.遍历原entry数组,通过对所有的entry节点进行重新Hash

Hash冲突的处理方式
	注:put操作中会先比较相同数组下标下key的值在比较key的hashCode值
			a.只有两者都相同才会覆盖原本的value值
			b.hashCode值相等,key值不一致就会出现hash冲突,此时该数组下标下存储的就是entry链,该链的插入法和jdk版本有关
			c.当想要找entry链中的某个entry实体时只能通过循环查找
	1.hashMap采用的是链地址法,一个数组下标下存储一个entry链表(尾插法)
	2.开放定址法(线性探测再散列,二次探测再散列,伪随机探测再散列)
	3.在hash法,直到不重复
	4.建立公共溢出区,把冲突的放入其中,不在表里面


Math():
	BigDecimal.subtract()//减
	BigDecimal.multiply()//乘
	BigDecimal.divide(被除数,保留小数位,BigDecimal.ROUND_HALF_UP)//四舍五入,向上舍入
	BigDecimal.setScale()//各种进位,第一个参数是保留的位数,第二参数是进位方式

Jackson,FastJson,Gson:
  FastJson: 序列化速度快,高并发下性能优异,可能存在安全问题,核心代码质量较差
  Gson: 核心结构简单,序列化性能较差,反序列化性能较为优异
  Jackson: springboot默认类库,在个方面都较为优异
  序列化性能: Fastjson>=Jackson>Gson
  反序列化性能: 三者差不多,Gson略好点

  Jackson的使用:
    ObjectMapper mapper = new ObjectMapper();
    String json = mapper.writeValueAsString(query);//序列化
    mapper.readValue(json,query.getClass());//反序列化

  Gson的使用:
    String json = new Gson().toJson(query,query.getClass());//序列化
    new Gson().fromJson(json,query.getClass());//反序列化

  FastJson的使用:
    String json = JSONObject.toJSONString(query);//序列化
    JSONObject.parseObject(json,query.getClass());//反序列化

class<?>和class<T>的区别
  T: 固定的一种泛型
  ?: Object的子类都可以

父类转子类
	子类转父类可以直接转: Parent son = new Son();
	父类转子类:
		先采用JSONObject把Parent转成String,在强转成Son对象
		Son son = JSONObject.parseObject(JSONObject.toJSONString(new Parent()),Son.class)


项目中使用map和实体类(javabean)作为参数的优缺点
	map
		优点:
			1.灵活性强于javabean,易扩展,耦合度低
			2.写起来简单,代码量少
			3.mabatis查询的返回结果本身就是map,效率更高
		缺点:
			1.javabean在数据输入编译期就会对数据类型进行校验,如果出错会直接提示,而map的数据类型需要到sql层才会进行数据校验
			2.map的参数名称如果写错,也需要到sql层才能判断是不是字段写错,不利于调试,javabean编译期就可发现
			3.map参数值如果多传,乱传才能判断是不是字段写错,且无法知道map中参数个数,类型,参数含义,不利于维护
	javabean
		优点:
			1.完美诠释java的面向对象理论
			2.数据结构清晰,便于团队开发,后期维护
			3.代码健壮,可以排除编译期报错
		缺点:
			1.代码量增多,大量时间去封装对象,影响开发效率


索引失效的场景:
  1.条件中有or,即使部分条件带索引也不会使用索引(要想使用or且使用索引,需要对or的字段添加索引)
  2.对于复合索引,如若不使用前列索引,则后续列的索引也将不生效(复合索引失效)
  3.like查询以%开头将不生效
  4.where中条件不加'',索引不生效
  5.where条件中有数学运算,函数等也将导致索引不生效


索引的不适用场景:
  1.数据唯一性差
  2.字段频繁更新
  3.where中包含is null和is not null和<>

什么字段不适合建索引
	1.大文本字段或超长字段不要建索引
	2.BLOB和CLOB类型字段不适合建索引
	3.大量重复数据的字段不适合建索引

oralce分区表
	横向分: 按数据内容(某个业务字段)
	纵向分: 表字段个数
	提高查询效率,

oracle插入多条数据:
INSERT ALL INTO TABLE_NAME VALUES(1,ZJ)
INTO TABLE_NAME VALUES (2,ZH) 
select 1 from dual
  1.使用insert all into 不是 insert into
  2.最后跟的selecr 1 from dual语句中的dual表可以被替换为任何一个只要不是当前表的其他表
  3.和mysql的批量插入不同,只适合于oracle 9i版本以上

mysql插入多条数据
INSERT INTO TABLE_NAME(name, age) VALUES('ZJ', 233), ('ZH', 233);


mysql调优
	1.主键,聚簇索引和非聚簇索引
	2.为什么索引是B+树
	3.explian查看sql的执行计划(按sql的执行计划修改一定是最优)
	4.走索引一定比不走索引快吗


如何保证Object是默认的父类
  1.在编译源代码时,遇到没有父类的类,编译器会给其指定一个默认的父类(Object),当虚拟机在处理该类时发现已有父类就按正常处理
  2.当编译时没有对无父类的类做处理,在虚拟机中将会自动将该类看成Object的子类
  注:java就属于第一种方式指定父类


isPrimitive(): 判断Class对象是否是八大基础类型


try-catch和throws的使用场景
	try-catch: 在当前位置处理异常
	throw: 向上抛出异常,理论上可以无限往上抛,直到main方法,最终抛给JVM虚拟机来解决
	注: 相当于throws可以把异常向上指定抛到某个类中集中解决异常(使用try-catch解决),而try-catch是在当前直接处理异常

catch中直接输出 e.printStackTrace()容易导致的事故:
  1.当代码本身存在问题的前提下
  2.短时间内出现大量请求
  3. e.printStackTrace()大量异常的堆栈信息输出到控制台
  4.错误堆栈的字符串占用字符串池内存空间,导致空间被占满
  5.大量生成字符串的线程阻塞,等待内存分配
  6.线程之间相互等待,等待内存,最终导致死锁,整个进程挂掉

死锁:
  多线程进行资源竞争导致陷入僵局
  两个或两个以上的进程在执行过程中,由于资源的竞争或者彼此间通信照成阻塞的一种现象,若无外力将无法推进下去,这种永远在相互等待的进程叫死锁进程
  锁死就是两个线程同时占用两个资源,但又在彼此等待对方释放锁

如何避免死锁:
  1.按同一顺序访问对象(避免出现循环)
  2.避免事务中的用户交互(减少持有资源时间,减少锁竞争)
  3.保持事务简短并处于一个批处理中(减少持有资源的时间)
  4.使用较低的隔离级别(使用较低的隔离级别(例如已提交读)比使用较高的隔离级别(例如可序列化)持有共享锁的时间更短,减少锁竞争)
  5.使用基于行版本控制的隔离级别
  6.银行家算法: 先试探给进程资源,通过安全性算法判断分配后的系统是否处于安全状态,若不安全则试探分配作废,进程继续等待


mybatis-puls的特性:
  1.无侵入: 在Mybatis上进行扩展,只增强不改变,支持所有原生的特性
  2.依赖少: Mybatis,Mybatis-Spring
  3.耗损小: 启动自动注入基本的CURD,性能基本无损耗,直接面向对象操作
  4.预防sql注入: 内置Sql注入剥离器,有效预防Sql注入攻击
  5.通用CURD: 通过配置实现大部分CURD,且有条件构造器,满足各类使用需求
  6.多种主键策略: 支持多大4种主键策略(内含分布式唯一ID生成器),可自由配置,解决主键问题
  7.支持热加载: Mapper对应的XML支持热加载,对于简单的CURD,甚至可以无xml启动
  8.支持ActiveRecord: 实体只需要继承Model类即可实现基础CURD操作
  9.支持代码生成: 使用代码或插件可以快速生成各层级代码
  10.支持自定义全局通用操作: 全局通用方法注入(Write once, use anywhere)
  11.支持关键词自动转义: 支持数据库关键词(order,key)自动转义,还可以自定义关键词
  12.内置分页插件: 无需关系具体操作,配置好操作后,写分页等同于普通List查询
  13.内置性能分析插件: 可输出Sql语句以及其执行时间,建议开发测试启动该功能,能有效解决慢查询
  14.内置全局拦截插件: 提供权标delete,update,智能分析,阻断,预防误操作


事务隔离级别及解决的问题:
  脏读: (针对未提交的数据)
     A事务更新了数据没提交,B事务查到了,结果A事务回滚了,则B事务查到数据就变成脏数据
  不可重复读: (针对其他提交前后,读取数据本身的对比)
     A事务中前后两次查询数据,期间B事务对数据做了更新,结果两次查到的数据不同
  幻读: (针对其他提交前后,读取数据条数的对比)
     A事务中前后多次查询,得到的数据结果集不一样(条数)
  不可重复读和幻读的区别: (数据变化和条数变化的区别)
     不可重复读重点在于前后数据的修改,幻读的重点在于新增和删除(数据集条数的不一样)

  1.级别1：read uncommitted : 
    读取尚未提交的数据,任何问题都不能解决(脏读,不可重复度,虚读)
    注: 一个事务可以读取另一个事务并未提交的更新结果

  2.级别2：read committed：
    读取已经提交的数据(可以读取到其他事务提交的update更新和insert新增),可以解决脏读,oracle默认的
    注: 一个事务只有提交更新操作后,另一个事务才能读取到更新的数据
        可能会出现一个事务中第一次读取到数据为1,第二次在去读取发现变成2了,不能保证一个事务中前后数据的一致性
	即前后是可重复读的,不是不可重复读的

  3.级别4：repeatable read：
    重读读取(只能读取其他事务已经提交的insert新增数据),可以解决脏读和不可重复读,mysql默认的
    注: 一个事务中前后读取到的数据是一致的,不受其他事物在此期间对数据更新影响,但是其他事务可以插入数据

  4.级别8：serializable：
    串行化:可以解决脏读,不可重复读和幻读---相当于锁表
    注: 事务依靠顺序执行,幻读的重点在于新增和删除(数据条数的变化)


mysql/oracle的锁(无锁,偏向锁,轻量级锁,重量级锁)


volatile:
  定义:JVM关键字,告诉JVM工作内存的值是不精确的,需要在主存中取,会专门把工作内容中的值刷到主内存中
  1.volatile是针对变量级别的关键字
  2.可以保证变量的可见性(指其他线程对变量的操作,本线程可见),一般可以用在大数据量循环的变量修饰上
  3.不保证原子性,故此不会造成线程的阻塞
  4.修饰的变量不会被编译器优化


反射的优缺点:
  优点: 可以在代码运行期间,动态的加载类,提高代码的灵活度 
  确定:
    1.性能瓶颈: 反射相当于需要通过JVM做一系列的解释操作,会加重JVM的负荷影响性能,比直接的java代码执行要慢很多
    2.安全问题: 可以动态的改变类的属性,同时也增加了类的安全隐患

反射影响性能为啥框架中还用到了反射技术
  项目开发中比较少会直接用到反射机制,但是在很多设计上会用到反射
  1.模块化的开发,通过反射去调用对应的字节码
  2.动态代理设计模式也采用了反射机制
  3.Spring,Hibernate等框架也大量使用了反射机制
    1).使用jdbc连接数据库使用Class.forName(),通过反射加载数据的驱动程序
    2).Spring的IOC(动态加载管理bean)创建对象和AOP(动态代理)


JDK动态代理和CGLIB动态代理的区别
  1.JDK动态代理只能代理实现了接口的类,CGLIB则可以代理未实现接口的类
  2.CGLIB是通过生成被代理类的子类来拦截被代理类的方法调用,因此不能代理final修饰的类和方法
  3.大部分情况下JDK动态代理的效率更高(随着jdk版本的升级,优势将会更加明显)

线程池的参数:
	corePoolSize: 核心线程数
	maximumPoolSize: 最大线程数
	keepAliveTime: 线程池中超过核心线程数的空闲线程最大存活时间,当设置了allowCoreThreadTimeout(true)则也表示核心线程的空闲的有效时间
	timeUnit: keepAliveTime的时间单位
	workQueue: 阻塞队列
	threadFactory: 新建线程工厂
	rejectedExecutionHandler: 当提交任务数导致最大线程数使用完毕后,之后提交的任务就会触发拒绝策略

线程池的阻塞队列:
  SynchronousQueue: 无缓存无界阻塞队列,新任务进来不会缓存,而是直接被线程调用,当任务数大于核心线程数时则创建新线程来处理,直到任务大于最大线程数则执行拒绝策略
	ArrayBlockingQueue: 基于数组的有界阻塞队列,按FIFO(先进先出)排序.尾插法,有界的数组可以防止资源耗尽问题.当线程池中线程数量达到corePoolSize后,再来新任务后会将任务放入该队列的队尾,等待被调度.如果队列已经是满的,则创建一个新线程,如果线程数量已经达到maxPoolSize,则会执行拒绝策略


线程池的拒绝策略:(RejectedExecutionHandler)
	注: 如下几种策略类都实现了RejectedExecutionHandler接口
	1.AbortPolicy: 线程池默认策略,如果任务添加到线程池失败,会直接抛出RejectedExecutionException异常
	2.DiscardPolicy: 当任务添加到线程池失败,则直接丢弃该请求,不抛弃异常
	3.DiscardOldestPolicy: 当任务添加到线程失败,会将队列中最早添加的任务移除,在尝试添加,如果失败则按该策略迭代重试
	4.CallerRunsPolicy: 当任务添加到线程池失败,那么主线程会自己调用执行器中的execute方法来执行该任务
	5.自定义Policy: 自定义符合场景的拒绝策略,需要实现RejectedExecutionHandler接口,并将自己的逻辑写在重写的rejectedExecution方法内

Q:线程池中有没有可能后创建的请求,先执行?
A:有,当和核心线程满了,队列也满了,最大线程没满,此时的请求过来会再建一个线程,这个心线程首先执行该请求,然后不停的从队列中取任务执行

需要使用到线程的场景
	1.高并发,任务执行时间短
	2.并发不高,任务执行时间长
	3.并发高,业务执行时间长


crontab的语法规则:
  分钟(0-59) 小时(0-23) 日期(1-31) 月份(1-12) 周(0-7) 命令(command)
  注:周的数字"0"和"7"都代表"星期天"
  前5个时间单位的特殊字符:
    *(星号): 代表任何时刻都接受的意思 例: 0 12 * * * (每月每周每日的12:00执行)
    ,(逗号): 代表分隔时段的意思 例: 0 3,6 * * * (每天的3:00和6:00执行)
    -(减号): 代表一段时间范围内 例: 20 6-9 * * * (每天的6点到9点之间每小时的20分钟都执行)
   /n(斜杆): 代表每隔n时间单位的意思 例: */5 * * * * (每隔5分钟执行一次)


Openjdk和Sunjdk的区别使用
	1.授权协议不同
		openjdk采用GPL V2协议(允许商用),Sunjdk采用JRL协议(允许个人)
		openjdk不允许部署功能
	2.openjdk源代码不完整,缺乏运维人员


select *和select所有字段的区别
	1.两者执行性能差距不大,字段的方式可以减少网络传输
	2.减少数据负担,select *需要查询表的列数据,影响网络传输的性能(效率差距不大)
	3.select字段扩展性更强,对字段的操作更加明了

主键,外键,索引
	主键: 记录的唯一标识,不允许为空,保证数据唯一性,只能有一个
	外键: 另一张表的主键,可以重复,可以为空,用于和其他表建立联系,一个表可以有多个外键
	索引: 该字段没有重复值,但可以有一个空值,提高查询排序的速度,一个表可以有多个索引

聚集索引和非聚集索引
	1.一个表只能拥有一个聚集索引,一般为主键,它和数据行的物理顺序保持一致
	2.聚集索引的叶子节点就是对应的数据节点,可以直接获取对应的全部列,非聚集索引在索引没覆盖列时,需要进行二次查询,聚集索引的查询速度更快
	3.如果不创建索引,系统会创建一个隐含列作为表的聚集索引
	4.一个表可以拥有多个非聚集索引,和物理存储顺序不同
	5.非聚集索引的叶子节点任然是索引节点,只是指针指向对应数据块
	6.使用非聚集索引查询,当查询的列中包含该索引没有的列,那么还会进行二次查询,查询节点上对应行确实的列数据
	7.聚集索引不一定比非聚集索引快(只查询两个字段,直接使用复合索引最快)
	8.主键上创建聚集所以比主键上创建非聚集索引慢的原因
		a.主键有唯一性的约束,需要保证数据插入的不重复
		b.聚集索引的叶节点就是数据节点,要检查主键唯一性就需要遍历所有的数据节点
		c.非聚集索引,的叶节点还是索引节点,只是索引节点有指针指向最终数据页,故此只需遍历索引节点即可,减少了很多IO消耗


ftp开启被动模式
	ftp = new FTPClient();
  ftp.connect(addr,port);
  ftp.login(username,password);
  ftp.enterLocalPassiveMode();


double在运算中存在舍入误差,故此在做精密计算时需要采用BigDecimal


无锁,偏向锁,轻量级锁,重量级锁定义和差别
	无锁: 
	偏向锁: 
	轻量级锁: CAS,避免了互斥量开销,如果存在竞争则速度比重量级锁更慢.
	重量级锁: Synchronized

使用druid生成数据库密码密文
	1.进入到druid的jar包目录
		cd /home/ntm/lib
		java -cp druid-1.1.9.jar com.alibaba.druid.filter.config.ConfigTools ntm(需要加密的明文)

RSA加解密的关键点
	1.公钥加密,私钥解密
	2.公私钥和加密后的密文需要在同一维度,即密文是由该组公钥生成的,不能用另一组私钥来解密
	3.同组公私钥每次生成的密文都是不同的,不过它支持解密旧的密文
	4.每次生成的公私钥组都是不同的

正则表达式
	\d: 数字类型
	\D: 非数字类型
	\w: 数字,字母,下划线
	\W: 非数字,字母,下划线
	\s: 表格,换行,tab键等空白
	\S: 非空白区域

synchronized,volatile的cpu原语是如何实现


线程间通信,进程间通信,跨机器进程间通信


线程和纤程的区别,纤程比较轻量级


ThreadLocal的原理及是否存在内存泄漏问题


redis的哨兵模式
	1.

redis的分布式锁实现

AQS(Abstract Queued Synchronizer)

JWT(token)

APM(Application Performance Management):应用性能管理

CAS(Compare And Swap)



